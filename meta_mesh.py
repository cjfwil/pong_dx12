#!/usr/bin/env python3
"""
Generate static mesh data for greybox primitives.
Output: src/generated/mesh_data.h
"""

import os
from pathlib import Path
from collections import namedtuple

# Simple vertex representation
Vertex = namedtuple('Vertex', ['position', 'uv'])
Vec3 = namedtuple('Vec3', ['x', 'y', 'z'])
Vec2 = namedtuple('Vec2', ['x', 'y'])

def gen_cube():
    """Generate 24 vertices (4 per face) and 36 indices for a cube."""
    vertices = []
    indices = []

    s = 0.5  # half‑size

    # Define the 8 corner positions
    corners = [
        Vec3(-s, -s, -s),  # 0
        Vec3( s, -s, -s),  # 1
        Vec3( s, -s,  s),  # 2
        Vec3(-s, -s,  s),  # 3
        Vec3(-s,  s, -s),  # 4
        Vec3( s,  s, -s),  # 5
        Vec3( s,  s,  s),  # 6
        Vec3(-s,  s,  s),  # 7
    ]

    # UVs for each corner of a face (in order: bottom‑left, bottom‑right, top‑right, top‑left)
    uvs = [
        Vec2(0, 1),  # bottom-left
        Vec2(1, 1),  # bottom-right
        Vec2(1, 0),  # top-right
        Vec2(0, 0),  # top-left
    ]

    # Face definitions: each face is a quad of 4 corners in counter‑clockwise order when viewed from outside
    # Format: [corner_indices], [uv_indices] (we use the same uv order for all faces)
    faces = [
        # bottom (y = -s)
        ([3, 2, 1, 0], uvs),
        # top (y =  s)
        ([4, 5, 6, 7], uvs),
        # front (z =  s)
        ([7, 6, 2, 3], uvs),
        # back (z = -s)
        ([0, 1, 5, 4], uvs),
        # left (x = -s)
        ([4, 7, 3, 0], uvs),
        # right (x =  s)
        ([1, 2, 6, 5], uvs),
    ]

    base_index = 0
    for (corner_idxs, face_uvs) in faces:
        # Add the 4 vertices for this face
        for i in range(4):
            pos = corners[corner_idxs[i]]
            uv = face_uvs[i]
            vertices.append(Vertex(pos, uv))

        # Generate two triangles: 0,1,2 and 0,2,3
        indices.append(base_index + 0)
        indices.append(base_index + 1)
        indices.append(base_index + 2)
        indices.append(base_index + 0)
        indices.append(base_index + 2)
        indices.append(base_index + 3)

        base_index += 4

    return vertices, indices


def gen_cylinder(slices=16):
    """Placeholder: generate a cylinder mesh."""
    vertices = []
    indices = []
    # TODO: implement later
    return vertices, indices


def gen_prism():
    """Placeholder: generate a triangular prism mesh."""
    vertices = []
    indices = []
    # TODO: implement later
    return vertices, indices


def write_header(path, cube_verts, cube_idxs, cyl_verts, cyl_idxs, prism_verts, prism_idxs):
    """Write the generated mesh data to a C header file."""
    with open(path, 'w') as f:
        f.write("// Generated by meta_meshes.py - DO NOT EDIT\n")
        f.write("#pragma once\n")
        f.write('#include "renderer_dx12.h" // for Vertex\n\n')

        # ------------------------------------------------------------------
        # Cube
        # ------------------------------------------------------------------
        f.write(f"static const Vertex kCubeVertices[{len(cube_verts)}] = {{\n")
        for v in cube_verts:
            f.write(f"    {{{{{v.position.x}f, {v.position.y}f, {v.position.z}f}}, {{{v.uv.x:.1f}f, {v.uv.y:.1f}f}}}},\n")
        f.write("};\n\n")

        f.write(f"static const uint32_t kCubeIndices[{len(cube_idxs)}] = {{\n    ")
        for i, idx in enumerate(cube_idxs):
            if i != 0 and i % 12 == 0:
                f.write("\n    ")
            f.write(f"{idx}, ")
        f.write("\n};\n\n")

        f.write(f"static const UINT kCubeIndexCount = {len(cube_idxs)};\n\n")

        # ------------------------------------------------------------------
        # Cylinder (placeholder)
        # ------------------------------------------------------------------
        if cyl_verts:
            f.write(f"static const Vertex kCylinderVertices[{len(cyl_verts)}] = {{ ... }};\n")
            f.write(f"static const uint32_t kCylinderIndices[{len(cyl_idxs)}] = {{ ... }};\n")
            f.write(f"static const UINT kCylinderIndexCount = {len(cyl_idxs)};\n\n")
        else:
            f.write("// Cylinder mesh not yet generated\n\n")

        # ------------------------------------------------------------------
        # Prism (placeholder)
        # ------------------------------------------------------------------
        if prism_verts:
            f.write(f"static const Vertex kPrismVertices[{len(prism_verts)}] = {{ ... }};\n")
            f.write(f"static const uint32_t kPrismIndices[{len(prism_idxs)}] = {{ ... }};\n")
            f.write(f"static const UINT kPrismIndexCount = {len(prism_idxs)};\n\n")
        else:
            f.write("// Prism mesh not yet generated\n\n")

    print(f"✓ Wrote {path}")


def main():
    # Ensure output directory exists
    out_dir = Path("src/generated")
    out_dir.mkdir(parents=True, exist_ok=True)
    out_path = out_dir / "mesh_data.h"

    # Generate meshes
    cube_verts, cube_idxs = gen_cube()
    cyl_verts, cyl_idxs = gen_cylinder()   # placeholder
    prism_verts, prism_idxs = gen_prism()  # placeholder

    # Write header
    write_header(out_path, cube_verts, cube_idxs, cyl_verts, cyl_idxs, prism_verts, prism_idxs)

    print(f"✅ Mesh generation complete. Generated cube with {len(cube_verts)} vertices, {len(cube_idxs)} indices.")


if __name__ == "__main__":
    main()